```{r}
library(stats)
library(stacomiR)
library(dplyr)
library(ggplot2)
```

```{r}
# import fish migration data
require(stacomiR)
data(package="stacomiR") # all fish migration datasets available

stacomi(database_expected=FALSE)    
```

```{r}
data("r_mig_interannual_vichy")
assign("r_mig_interannual_vichy",r_mig_interannual_vichy,envir=envir_stacomi)

df <- r_mig_interannual_vichy@data
df <- df %>% filter(bjo_labelquantite=="Effectif_total") %>%
  select(c(bjo_identifiant, bjo_dis_identifiant,
           bjo_annee, bjo_jour, bjo_valeur)) %>%
  mutate(bjo_valeur = case_when(bjo_valeur < 0 ~ 0,
                                TRUE ~ bjo_valeur)) %>%
  rename(sample_id=bjo_identifiant, dc_id=bjo_dis_identifiant,
         year=bjo_annee, timestamp=bjo_jour, value=bjo_valeur)

# Extract single feature we want to predict (and drop any NAs)
migrations <- df %>% select(c(timestamp, value))
migrations <- na.omit(migrations)  # Remove NAs
```

```{r}
# Visualize the time series
ggplot(migrations %>% filter(timestamp < "2000-05-21 01:00:00"), aes(x = timestamp, y = value)) +
  geom_line() +
  ggtitle('Fish Sightings History') +
  xlab('Time') +
  ylab('Sightings') +
  theme_minimal()
```

```{r}
# Lag and ACF Plots
# Creating lag features (to do the analysis manually)
for (i in 1:365) {
  migrations[, paste0('Lag_', i)] <- c(rep(NA, i), head(migrations$value, -i))
}

# Drop rows with missing values due to lagging
migrations <- na.omit(migrations)

# Autocorrelation Function
acf(migrations$value, main = "Sightings ACF Plot")
```

```{r}
lag = 360

# Split into training and test sets
train_size <- round(0.8 * nrow(migrations))
train_data <- migrations[1:train_size,]
test_data <- migrations[(train_size + 1):nrow(migrations),]

# Define y_train and y_test
y_train <- train_data$value
y_test <- test_data$value

# Confirm that Lag 10 still has a large correlation
cor(migrations$value, lag(migrations$value, n = 360), use = "complete.obs")
```

```{r}
# AR(30) model
X_train <- train_data %>% select(paste("Lag", 1:lag, sep = "_"))

# Fit AR(30) Model (OLS)
X_matrix <- as.matrix(cbind(1, X_train))  # Add intercept column (if desired)
y_vector <- as.matrix(y_train)
w <- solve(t(X_matrix) %*% X_matrix) %*% (t(X_matrix) %*% y_vector)

# Predict migration using AR(30)
y_pred <- numeric(length(y_test))
start <- as.matrix(tail(X_train, 1))

for (i in 1:length(y_test)) {
  y_pred[i] <- as.numeric(w[1] + start %*% as.matrix(w[2:(lag+1)]))
  start <- c(y_pred[i], start[1:(lag-1)])
}

# Observed vs predicted plot
plot(y_pred, y_test, ylab = "Observed Migration", xlab = "Predicted Migration", 
     main = "AR(30) Model Predictions")
abline(0, 1, col = "red")
```
```{r}
# Time series plot of actual vs predicted SO9
plot(test_data$timestamp, test_data$value, type = "l", col = "blue", lwd = 2, ylim = range(c(y_pred, test_data$value)), xlab = "date", ylab = "migration count", main = "AR(365) Model Predictions")
lines(test_data$timestamp, y_pred, col = "red", lwd = 2, lty = 2)
legend("topleft", legend = c("Actual Migration", "AR(365) Predicted Migration"), col = c("blue", "red"), lty = c(1, 2), bty = "n")

```


